
# 코디 완성 서비스

## 기본 설정
- 8개의 카테고리가 존재한다 (상의, 아우터,바지, 스니커즈, 가방, 모자, 양말, 액세서리)
- 9개의 브랜드가 존재하고 각 브랜드는 추가, 삭제, 수정이 가능하다.
- 상품은 카테고리, 브랜드와 가격을 가지고 있으며 추가, 삭제, 수정이 가능하다.
- 요구사항은 총 4개이며 각 요구사항에 만족하는 API를 제공해야한다.
- API는 JSON 형태로 응답해야하며 실패시 실패값과 실패 사유를 전달해야한다.

## 참고사항 
- 데이터를 삭제할때 soft delete를 사용하도록 처리하였으며 삭제된 데이터는 조회되지 않도록 처리하였습니다.
- 매번 조회시 삭제된 데이터를 제외하는 조건을 넣는 방식이 해당 프로젝트에서는 불필요하다고 판단하여 SQLRestriction을 사용하였습니다.
- 삭제된 데이터를 조회해야하는 요구사항이 생길경우에는 관리자 로직을 별도로 구현하거나 데이터 조회시 삭제된 데이터 제외 조건을 넣는 방식으로 변경이 필요합니다.

## 도메인 정리
- Category
  - 상품의 카테고리 정보를 갖는 객체, 카테고리 id와 이름을 가진다.
- Brand
  - 상품의 브랜드 정보를 갖는 객체, 브랜드 id와 이름을 가진다.
- Product
  - 상품 정보를 갖는 객체, 상품 id, 카테고리, 브랜드, 가격을 가진다.
- Products
  - 여러 상품정보와 총 가격정보를 가진 객체, 해당 프로젝트에서는 최저가격의 상품정보를 저장하는 용도로 사용된다
- BrandProducts
  - 가장 낮은 가격정보를 가진 브랜드 객체, 브랜드 이름과 해당 브랜드의 상품정보, 총 가격정보를 가진다.
- LowestAndHighestPriceProducts
  - 카테고리별 최저가격 상품과 최고가격 상품을 가진 객체

## 프로젝트 구조 설명
```
coordination
├── brand         -> 브랜드 관련 패키지
├── category      -> 카테고리 관련 패키지
├── common        -> exception, uitl 등 공통 기능 관리용 패키지 
├── product       -> 상품 관련 패키지
└── style         -> 상품정보를 이용한 코디 추천 관련 패키지
```
각각의 하위 페이지에는 아래와 같은 구조로 구성되어있습니다..
- presentation : API 요청을 처리하는 컨트롤러
- domain : 도메인 객체를 정의하는 패키지, 비즈니스 로직을 처리하는 객체를 가짐
- infrastructure: 데이터 베이스등 데이터 저장소에 접근 담당 
- application : domain 객체를 이용해 비즈니스 로직을 처리하는 서비스 객체

## 구현 내용 설명
### 데이터 조회 방식
- 현재 상황에서는 상품 수가 많지 않아 상품정보를 모두 조회하여 처리하는 방향으로 구현하였습니다.   
- 모든 비즈니스 로직을 DB에서 처리하는 방식도 고려하였지만 DB에 의존적으로 될 것 같아 애플리케이션에서 처리하였습니다. (DB에서 처리할 경우 성능적으로는 더 좋을 순 있지만 디버깅, 테스트 어려움 등 유지보수 측면에서 관리가 어려움)    
- 단 같은 카테고리, 브랜드의 상품정보를 가져올 때는 최저가격만 가져오도록 처리하였습니다.
- 해당 로직을 애플리케이션에서 처리하기 위해선 stream을 사용하여 조회하는 것보단 DB의 MIN 함수를 이용하는 것이 더 효율적이라 생각했습니다.    
- 추후 상품 수가 많아질 경우 최저가격 상품정보를 따로 저장하는 방식 등으로 변경이 필요합니다.

### 캐시 정책
- 로컬 캐시를 적용하였습니다. 다중화 환경이나 캐시 되는 데이터의 양이 많아질 경우 글로벌캐시(Reds 등)를 사용하는 것이 더 효율적입니다.
- 현재 상황에서는 원활한 테스트를 위해 캐시 만료 시간을 1초로 적용하였습니다.
- 상품정보 변경이 거의 발생하지 않는다면 만료 시간을 높은 값으로 설정한 뒤 상품정보 변경 시 캐시 데이터를 갱신해 주는 방식으로 변경이 필요합니다.
- 로컬 캐시 사용 시 캐시 데이터가 만료되는 시점에 트래픽이 많이 몰리는 상황이 발생할 경우 불필요한 캐싱이 발생하여 메모리 부족 현상이 발생할 수 있습니다.

### 비즈니스 로직 처리 방식
- 각 요구사항에 맞는 비즈니스 로직을 처리하는 Factory 클래스를 만들어 처리하였습니다.   
- Factory에서는 요구사항 조건을 확인하고 응답 결과에 필요한 도메인 객체를 만들어 반환합니다.

### API 응답 방식
- 요구사항에 상품 응답 정보에 필요한 데이터가 상이하여 각 요구사항에 맞는 상품 응답 클래스(Product Response)를 만들어 사용하였습니다.    
- 실제 상황에서는 상품정보를 응답한 후 후속 작업(상품 구매, 상품 정보 조회 등..)을 위해선 상품 Id 값이 필요할 것으로 예상되어 공통 상품 응답 클래스를 만들어 사용할 것 같습니다.
```java
// 예시
public record ProductResponse(Long id, String name, Long price, BrandResponse brand, CategoryResponse category) {}
public record BrandResponse(Long id, String name) {}
public record CategoryResponse(Long id, String name) {}
```
실패시에는 실패값과 실패 사유를 응답하도록 처리하였습니다.

### 테스트 방식
- 테스트는 각 도메인별 기능이 정상적으로 동작하는지 확인하는 단위테스트와 비즈니스 로직을 만족하는지 확인하는 통합테스트를 작성하였습니다.

## 코드 빌드, 테스트, 실행 방법
### 빌드 및 테스트
```shell
./gradlew clean build
```
### 테스트
```shell
./gradlew test
```
### 실행
```shell
./gradlew bootRun
```
### 각 API는 http 하위 폴더에있는 http파일을 통해 호출 가능합니다.

[브랜드 조회, 추가, 수정, 삭제 API](./http/brand.http)   
[상품 조회, 추가, 수정, 삭제 API](./http/product.http)   
[코디 추천 API](./http/style.http)

### 브랜드 조회, 상품 조회, 코디 추천 화면은 프로젝트 실행 후 http://localhost:8080 페이지에서 확인 가능합니다.

## 요구사항

- [x] 브랜드를 추가, 수정, 삭제 할 수 있다
- [x] 브랜드명을 추가할때 null이거나 빈값이 올 수 없다
- [x] 브랜드명은 중복될 수 없다
- [x] 상품을 추가, 수정, 삭제 할 수 있다
- [x] 상품은 브랜드, 카테고리, 가격정보를 가진다
- [x] 상품의 가격은 1 이상이다
- [x] 동일한 상품(브랜드, 카테고리가 같을경우)의 가격은 다를 수 있다
- [x] 동일한 상품은 최소 1개 이상 존재해야한다
- [x] 카테고리별 최저가인 상품을 조회할 수 있다.
- [x] 단일 브랜드로 구성된 상품 중 가격이 가장 낮은 상품을 조회할 수 있다.
- [x] 카테고리로 조회시 가격이 가장 높은 상품과 가장 낮은상품을 조회할 수 있다.